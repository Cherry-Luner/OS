| MIT6.S081 Lecture4 note |
| ----------------------- |

------

### 地址空间

每个程序都运行在自己的地址空间，并且这些地址空间彼此之间相互独立。在这种不同地址空间的概念中，cat程序甚至都不具备引用属于Shell的内存地址的能力。这是我们想要达成的终极目标，因为这种方式为我们提供了强隔离性，cat现在不能引用任何不属于自己的内存。



### 页表

**我们如何能够实现地址空间呢？或者说如何在一个物理内存上，创建不同的地址空间？**

最常见的方法，同时也是非常灵活的一种方法就是使用页表（Page Tables）。页表是在硬件中通过处理器和内存管理单元（Memory Management Unit）实现。

对于任何一条带有地址的指令，其中的地址应该认为是虚拟内存地址而不是物理地址。虚拟内存地址会被转到内存管理单元（`MMU`，Memory Management Unit，内存管理单元会将虚拟地址翻译成物理地址。之后这个物理地址会被用来索引物理内存，并从物理内存加载，或者向物理内存存储数据。

**从CPU的角度来说，一旦MMU打开了，它执行的每条指令中的地址都是虚拟内存地址。**

这里的基本想法是每个应用程序都有自己独立的表单，并且这个表单定义了应用程序的地址空间。所以当操作系统将CPU从一个应用程序切换到另一个应用程序时，同时也需要切换SATP寄存器中的内容，从而指向新的进程保存在物理内存中的地址对应表单。

一个真正的页表结构

<img src="E:\Typore-Picture\image-20221122120515258.png" alt="image-20221122120515258" style="zoom: 67%;" />

### TLB

TLB会保存虚拟地址到物理地址的对应关系，具体细节是硬件内部问题，不属于操作系统，知道作用是存储最近的虚拟地址和物理地址即可



### 内核页表

<img src="E:\Typore-Picture\image-20221122121553963.png" alt="image-20221122121553963" style="zoom:50%;" />

右边的所有事情均由主板上硬件决定，0x80000000上是RAM，0x80000000下是IO设备

PLIC是中断控制器（Platform-Level Interrupt Controller）我们下周的课会讲。

CLINT（Core Local Interruptor）也是中断的一部分。所以多个设备都能产生中断，需要中断控制器来将这些中断路由到合适的处理函数。

UART0（Universal Asynchronous Receiver/Transmitter）负责与Console和显示器交互。

VIRTIO disk，与磁盘进行交互。



**对于左边的**

当机器刚刚启动时，还没有可用的page，XV6操作系统会设置好内核使用的虚拟地址空间，也就是这张图左边的地址分布。

内核会按照这种方式设置page table，虚拟地址0x02000000对应物理地址0x02000000。

**你可以向同一个物理地址映射两个虚拟地址，你可以不将一个虚拟地址映射到物理地址。可以是一对一的映射，一对多映射，多对一映射。**



当kernel创建了一个进程，针对这个进程的page table也会从Free memory中分配出来。内核会为用户进程的page table分配几个page，并填入PTE。在某个时间点，当内核运行了这个进程，内核会将进程的根page table的地址加载到SATP中。从那个时间点开始，处理器会使用内核为那个进程构建的虚拟地址空间。

进程有由内核设置好的，专属于进程的page table来完成地址翻译。

**内核的页表在机器启动时设置,进程的页表由内核设置**

### Code

`main`函数中调用的一个函数是`kvminit`，这个函数会设置好kernel的地址空间

<img src="E:\Typore-Picture\image-20221122122640430.png" alt="image-20221122122640430" style="zoom:50%;" />

<img src="E:\Typore-Picture\image-20221122123432433.png" alt="image-20221122123432433" style="zoom:50%;" />

因为在这条指令之前，我们使用的都是物理内存地址，这条指令之后page table开始生效，所有的内存地址都变成了另一个含义，也就是虚拟内存地址。
