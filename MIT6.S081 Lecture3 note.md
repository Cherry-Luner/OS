| MIT 6.S081 Lecture3 note |
| ------------------------ |

### 操作系统的组织结构

1. **Isolation。隔离性是设计操作系统组织结构的驱动力。**
2. **Kernel和User mode。这两种模式用来隔离操作系统内核和用户应用程序。**
3. **System calls。系统调用是你的应用程序能够转换到内核执行的基本方法，这样你的用户态应用程序才能使用内核服务。**

[^隔离]: 页表和虚拟内存也是用来加强隔离的



1. **exec抽象了内存**
2. **process抽象了CPU**
3. **files抽象了磁盘****



#### 操作系统应当具有防御性

​	操作系统需要做好准备抵御来自应用程序的攻击

​	通过两种方法实现强隔离，提升OS的防御性

1. **user/kernel mode，设定用户态和内核态**
2. **page table或者虚拟内存**



#### 用户/内核模式切换

​	用户空间和内核空间的界限是一个硬性的界限，比如当调用fork()时，并不能直接调用内核中的sys_fork()，而是通过ecall这个

指令切换到内核模式，只有通过执行ecall这条指令一种办法进入内核。



​	假设我现在要执行另一个系统调用write，相应的流程是类似的，write系统调用不能直接调用内核中的write代码，而是由封装好的系统调用函数执行ECALL指令。所以write函数实际上调用的是ECALL指令，指令的参数是代表了write系统调用的数字。之后控制权到了syscall函数，syscall会实际调用write系统调用。



#### 编译运行内核

![](E:\Picture\17IZY$QTPF6AQZ9S3MVL7UX.png)



1. 第一个是内核。我们可以ls kernel的内容，里面包含了基本上所有的内核文件。因为XV6是一个宏内核结构，这里所有的文件会被编译成一个叫做kernel的二进制文件，然后这个二进制文件会被运行在kernle mode中。
2. 第二个部分是用户。这基本上是运行在用户模式的程序。这也是为什么一个目录称为内核，另一个目录称为user的原因。
3. 第三部分叫做mkfs。它会创建一个空的文件镜像，我们会将这个镜像存在磁盘上，这样我们就可以直接使用一个空的文件系统。



编译过程: 

​	Makefile会为所有内核文件做相同的操作，比如说pipe.c，会按照同样的套路，先经过gcc编译成pipe.s，再通过汇编解释器生成pipe.o。

​	之后，系统加载器（Loader）会收集所有的.o文件，将它们链接在一起，并生成内核文件。



我们来看传给QEMU的几个参数：

- -kernel：这里传递的是内核文件（kernel目录下的内核文件），这是将在QEMU中运行的程序文件。

- -m：这里传递的是RISC-V虚拟机将会使用的内存数量

- -smp：这里传递的是虚拟机可以使用的CPU核数

- -drive：传递的是虚拟机使用的磁盘驱动，这里传入的是fs.img文件



#### XV6启动

<img src="E:\Typore-Picture\image-20221116000957505.png" alt="image-20221116000957505"  />

​		内核加载器从**0x80000000**处加载内核，此时还处于**机器模式**

​		**这个时候没有内存分页，没有隔离性，并且运行在M-mode**

​		电脑开机时有小段时间是处于机器模式，用来初始化主机的，之后会转为内核模式

​		现在查看内核kernel.ld文件，如下图

![](E:\Typore-Picture\image-20221116001306274.png)



![](E:\Typore-Picture\image-20221116001849253.png)

函数`start`执行一些仅在机器模式下允许的配置，然后切换到管理模式。

下图处于`start.c`中，已经初始化机器了，执行mret转到内核态。

`mret`执行返回，返回到先前状态，由于`start`函数将前模式改为了管理模式且返回地址改为了`main`,因此`mret`将返回到`main`函数，并以管理模式运行。

![](E:\Typore-Picture\image-20221116002059207.png)



##### 进入`main.c`函数

**此前已经初始化pc，从机器模式到内核模式，内核也已经加载完毕**

进入`main.c`函数后，会初始化一系列东西为进程做准备

`kinit`：设置好页表分配器（页面分配器）

`kvminit`：设置好虚拟内存，这是下节课的内容

`kvminithart`：打开页表，也是下节课的内容

`processinit`：设置好初始进程或者说设置好进程表单

`trapinit/trapinithart`：设置好user/kernel mode转换代码

`plicinit/plicinithart`：设置好中断控制器PLIC（Platform Level Interrupt Controller）

`二进制`：分配缓冲区缓存

`iinit`：初始化inode缓存

`fileinit`：初始化文件系统

`virtio_disk_init`：初始化磁盘

`userinit`：最后当所有的设置都完成了，操作系统也运行起来了，会通过`userinit`运行第一个进程

![](E:\Typore-Picture\image-20221116002405323.png)



​		**`main.c`利用了XV6的特性，并启动了第一个进程。我们总是需要有一个用户进程在运行，这样才能实现与操作系统的交互，所以这里需要一个小程序来初始化第一个用户进程。这个小程序定义在`initcode`。**

<img src="E:\Typore-Picture\image-20221116002939836.png" style="zoom:80%;" />

在`main`初始化几个设备和子系统后，便通过调用`userinit` 创建第一个进程，**第一个进程**执行一个用RISC-V程序集写的小型程序：***initcode. S\*** ,它通过调用`exec`系统调用重新进入内核。一旦内核完成`exec`，它就返回`/init`进程中的用户空间。

**`init`就是第一个执行的进程**

<img src="E:\Typore-Picture\image-20221116005656088.png" style="zoom:80%;" />

`init`执行`fork`，子进程运行`shell`，完毕

**总结**

​		开机 -> `_entry`处加载内核 -> `start.c`在机器模式下初始化，退出时切换到内核模式并进入`mian.c` -> `main.c` 为执行进程做准备

-> 运行`initcode.S`初始化第一个进程 -> `exec`(`init`) -> `init`调用`fork`，子进程执行`shell`，至此`xv6`启动完毕

​		